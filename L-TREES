#math imports
from random import random
from math import radians, degrees, atan2, sqrt, copysign

import copy

#blender imports
import mathutils
from mathutils import Quaternion, Vector
import bpy

class Turtle(object):
    #perform the turtle movements
    
    #attributes of Turtele class
    dir = Vector([0.0, 0.0, 1.0])
    pos = Vector([0.0, 0.0, 0.0])
    right = Vector([-1.0, 0.0, 0.0])
    width = 0.0
    
    def __str__(self):
        return 'Turtle at %s, direction %s, right %s' % (self.pos, self.dir, self.right)
    
    def __init__(self, dir, pos, right, width):
        self.dir = dir
        self.pos = pos
        self.right = right
        self.width = width
      
    def yaw(self, ang):
        #positive angle moves to the right
        axis  = self.dir.cross(self.right)
        axis.normalize()
        
        rot = Quaternion(axis, radians(ang))
        
        self.dir.rotate(rot)
        self.dir.normalize()
        self.right.rotate(rot)
        self.right.normalize()
        
        
    def pitch(self, ang):
        #positive angle rises turtle's nose
        self.dir.rotate(Quaternion(self.right, radians(ang)))
        self.dir.normalize()
        
    def roll(self, ang):
        #positive angle turn right
        self.right.rotate(Quaternion(self.dir, radians(ang)))
        self.right.normalize()
        
    def move(self, step):
        #move the turtle forward
        self.pos += self.dir * step

    def setWidth(self, width):
        self.width = width
        
    def resetVertical(self):
           self.dir = Vector([0.0, 0.0, 1.0]) 
           self.right = Vector([-1.0, 0.0, 0.0])
    
    def copy(self):
        return Turtle(self.dir, self.pos, self.right, self.width)
 


class Branch(object):
    #attributes
    polyline = None
    start = Vector([0,0,0])
    turtle = None
    curve = None
    #handle lenght
    tang_l = 0.00
    #tropism constant
    trop_const = 0.001
    
    def __init__(self, curve, turtle, tropism):
        #set tropism
        axis = turtle.dir.cross(tropism)
        print(axis)
        rot = Quaternion(axis, self.trop_const*axis.length)
        turtle.dir.rotate(rot)
        turtle.dir.normalize()
        
        self.polyline = curve.splines.new('BEZIER')
        self.curve = curve
        self.turtle = copy.deepcopy(turtle)
        self.start = self.turtle.pos
        self.polyline.bezier_points[0].co = self.start
        
        self.polyline.bezier_points[0].radius = self.turtle.width
        
        self.polyline.bezier_points[0].handle_left = self.turtle.pos
        self.polyline.bezier_points[0].handle_right = self.turtle.pos
        
        self.tang_l = 1
        
        
class Tree(object):
    #stack to put the branches
    stack = []
    curve = None
    obj = None
    #main Branch object
    stem = None
    #tropism vector
    tropism = Vector([0,0,0])
      
    def __init__(self, turtle, tropism):
        self.tropism = tropism
        
        #create and bevel the curve
        self.curve = bpy.data.curves.new(name = "Tree",type='CURVE')
        self.curve.dimensions = '3D'
        self.curve.fill_mode = 'FULL'
        self.curve.bevel_depth = 0.045     
    
        #link the object to the scene
        self.obj = bpy.data.objects.new("Tree"+"Obj", self.curve)
        bpy.context.scene.collection.objects.link(self.obj)
        
        #create first branch and push into the stack
        self.stack.append(Branch(self.curve, turtle, self.tropism))
        
        #set the handles to the turtles point
        self.stack[0].polyline.bezier_points[0].handle_left = self.stack[0].turtle.pos
        self.stack[0].polyline.bezier_points[0].handle_right = self.stack[0].turtle.pos
        
        self.stem = self.stack[0]
        
        
    def move(self, step):
        #update tangent lenght
        self.stem.tang_l = step/100
        #move turtle
        self.stem.turtle.move(step)
        
        #add new point
        self.stem.polyline.bezier_points.add(1)
        self.stem.polyline.bezier_points[-1].co = self.stem.turtle.pos
        
        #handles direction tangent to the curve
        self.stem.polyline.bezier_points[-1].handle_left = self.stem.turtle.pos - self.stem.turtle.dir*self.stem.tang_l
        self.stem.polyline.bezier_points[-1].handle_right = self.stem.turtle.pos + self.stem.turtle.dir*self.stem.tang_l
        
        #set the curve radius to be the turtle's width
        self.stem.polyline.bezier_points[-1].radius = self.stem.turtle.width
        
    def pitch(self, ang):
        #set handle to be tangent to the segment
        self.stem.polyline.bezier_points[-1].handle_right= self.stem.turtle.pos + self.stem.turtle.dir*self.stem.tang_l
        
        #pitch the turtle
        self.stem.turtle.pitch(ang)
        
        #set handle to be tangent to the segment
        self.stem.polyline.bezier_points[-1].handle_left = self.stem.turtle.pos - self.stem.turtle.dir*self.stem.tang_l
        
    def roll(self, ang):
        #set handle to be tangent to the segment
        self.stem.polyline.bezier_points[-1].handle_right= self.stem.turtle.pos + self.stem.turtle.dir*self.stem.tang_l
        
        #roll the turtle
        self.stem.turtle.roll(ang)
        
        #set handle to be tangent to the segment
        self.stem.polyline.bezier_points[-1].handle_left = self.stem.turtle.pos - self.stem.turtle.dir*self.stem.tang_l
        
    def yaw(self, ang):
        #set handle to be tangent to the segment
        self.stem.polyline.bezier_points[-1].handle_right= self.stem.turtle.pos + self.stem.turtle.dir*self.stem.tang_l
        
        #yaw the turtle
        self.stem.turtle.yaw(ang)
        
        #set handle to be tangent to the segment
        self.stem.polyline.bezier_points[-1].handle_left = self.stem.turtle.pos - self.stem.turtle.dir*self.stem.tang_l
        
    def fork(self):
        #create new branch and push into the stack
        self.stack.append(Branch(self.curve, self.stem.turtle, self.tropism))
        #subscribe stem attribute with a new branch starting from the last vertex
        self.stem = self.stack[-1]
        
    def closeBranch(self):
        #set the radius to 0
        self.stem.polyline.bezier_points[-1].radius = 0
        #pop out of the stack
        self.stack.pop()
        #subscribe stem attribute with the previous branch
        self.stem = self.stack[-1]
        
    def setW(self, width):
        #set the curve radius at turtle location
        self.stem.polyline.bezier_points[-1].radius = width
        self.stem.turtle.setWidth(width)
        
    def resetOrientation(self):
        #set handle to be tangent to the segment
        self.stem.polyline.bezier_points[-1].handle_right= self.stem.turtle.pos + self.stem.turtle.dir*self.stem.tang_l
        
        #reset orientation of turtle
        self.stem.turtle.resetVertical()
        
        #set handle to be tangent to the segment
        self.stem.polyline.bezier_points[-1].handle_left = self.stem.turtle.pos - self.stem.turtle.dir*self.stem.tang_l
        
   
   
   
    
"""
TURTLE SYMBOLS

!(w) Set turtle width to w.
F(l) Move turtle forward by l .
+(a) Turn turtle left by a.
-(a) Turn turtle right by a.
&(a) Pitch turtle down by a.
^(a) Pitch turtle up by a.
/(a) Roll turtle right by a.
n(a) Roll turtle left by a.
[(0) Start branch.
](0) End branch.
$ Reset turtle to vertical
Q(w,l) Auxiliary symbol to branches: move l and set width to w
A(w,l) Auxiliary symbol to twigs: move l and set width to w
"""

def genSimpleSeq(itr, a, w):
    #simple 2d tree
    
    #generate sequence that will move the turtle
    #commands are in the form of a tuples list tuple("symbol",[value1, value2,...])
    #list of commands in the form of [("",[]), ("",[]), ("",[]), ("",[]), ("",[]), ("",[]), ("",[])] 
    #ex: ("^",[45])
    
    lsys = []
    
    #AXIOM
    lsys.append(("F",[w]))
    res = []
    
    #REWRITING
    #repat itr times, changing the values
    for num in range(itr):
        for x in lsys:
            #REWRITE RULES:
            if(x[0] == "F"):
                res += [("F", [w]), ("[",[]), ("+", [a]), ("F", [w]), ("]",[]), ("F", [w]), ("[",[]), ("-", [a]), ("F", [w]), ("]",[]), ("F", [w])]
            
            else:
                res += [(x[0],x[1])]
            ##      
        lsys = copy.deepcopy(res)
        res = []
    return lsys

def genSeq(itr, ang, base_w):
    #generate sequence that will move the turtle
    #commands are in the form of a tuples list tuple("symbol",[value1, value2,...])
    #list of commands in the form of [("",[]), ("",[]), ("",[]), ("",[]), ("",[]), ("",[]), ("",[])] 
    #ex: ("^",[45])
    
    lsys = []
    
    #AXIOM
    lsys.extend([("!",[base_w]), ("/",[45]), ("Q",[base_w, 0.5])])
    res = []
    
    #REWRITING
    #repat itr times, changing the values
    for num in range(itr):
        for x in lsys:
            #REWRITE RULES:
            
            #REWRITE RULE FOR Q
            if(x[0] == "Q"):
                #pick parameters
                w = x[1][0]
                l = x[1][1]
            
                #rewrite
                res += [("/", [75]), ("&",[ang]), ("!", [0.2*w]), ("[", []), ("A",[0.3*w, 1.5*sqrt(w)*0.9]), ("]", []), 
                        ("!",[w]), ("^", [ang]), ("F", [l]), ("Q",[max(0,w-base_w/14), l]), ("F", [w])]
            
            #REWRITE RULE FOR A
            elif(x[0] == "A"):
                #pick parameters
                w = x[1][0]
                l = x[1][1]
                w_d = w/(itr)
                wid = w - num/(w_d + 1)
        
                #rewrite
                res += [("!", [wid]), ("F",[l/3]), ("/", [140]), ("&", [ang]), ("!",[0.3*wid]), ("[", []), 
                        ("F",[0.75*sqrt(itr-num)*l/3]), ("^", [20]), ("F", [0.75*sqrt(itr-num)*l/3]), 
                        ("]",[]), ("!", [wid]), ("^",[ang]), ("n",[140]), ("^",[1.2])]
            
            else:
                res += [(x[0],x[1])]
            ##      
        lsys = copy.deepcopy(res)
        res = []
    print(lsys)
    return lsys


def parser(seq, tree):
    #transform sequence in steps
    for x in seq:
        ##interpreter rules
        
        if(x[0] == "!"): tree.setW(x[1][0])
        
        elif(x[0] == "F"): tree.move(x[1][0])
        
        elif(x[0] == "+"): tree.yaw((-1)*x[1][0])
        
        elif(x[0] == "-"): tree.yaw(x[1][0])
        
        elif(x[0] == "&"): tree.pitch((-1)*x[1][0])
        
        elif(x[0] == "^"): tree.pitch(x[1][0])
        
        elif(x[0] == "/"): tree.roll(x[1][0])
        
        elif(x[0] == "n"): tree.roll((-1)*x[1][0])
        
        elif(x[0] == "["): tree.fork()
        
        elif(x[0] == "]"): tree.closeBranch()
        
        elif(x[0] == "$"): tree.resetOrientation()
        
        elif(x[0] == "Q"): 
            tree.setW(x[1][0])
            tree.move(x[1][1])
        
        elif(x[0] == "A"): 
            tree.setW(x[1][0])
            tree.move(x[1][1])
        
        

    















dir = mathutils.Vector([0.0, 0.0, 1.0])
pos = mathutils.Vector([0.0, 0.0, 0.0])
left = mathutils.Vector([-1.0, 0.0, 0.0])
tropism = mathutils.Vector([0.0, 0.0, -100.0])
width = 10
tt = Turtle(dir, pos, left, width)
tr = Tree(Turtle(dir, pos, left, width), tropism)
parser(genSimpleSeq(4, 30, 10), tr)




